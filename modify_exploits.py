import mariadb
import dbconnect
import traceback

# Creating a function that allow hackers to modify their exploits
def modify_my_exploits(hacker_alias, hacker_id):
    # Connecting to the database and creating a cursor, checking to see if there is a successful database connection and whether the cursor was created
    conn = dbconnect.open_db_connection()
    cursor = dbconnect.create_db_cursor(conn)

    # If the connection to the database is successful but the cursor was not created, try to close the cursor and database connection, don't run the next lines of code
    if(conn == None or cursor == None):
        print("An error in the database has occured.")
        dbconnect.close_cursor(cursor)
        dbconnect.close_db_connection(conn)
        return

    print("\nPlease choose which exploit you would like to modify.")
    
    # If the hacker enters an invalid exploit, prompt the user to modify their exploit again
    while(True):
        # Using a try-except block to catch errors when a hacker modifies their exploits
        try:
            # Getting all of the hacker's exploits from the database
            cursor.execute("SELECT e.id, h.alias, e.content, h.id, e.hacker_id FROM hackers h INNER JOIN exploits e ON e.hacker_id = h.id WHERE h.id = ?", [hacker_id,])
            my_exploits = cursor.fetchall()

            # If there are no exploits found, print a message to the hacker
            if(len(my_exploits) == 0):
                print("\nNo posts found.")
                break
            # If there are more than one exploit found, print each hacker's exploit number, username, exploit and id so the hacker can see which exploit they would like to modify
            else:
                print("\nMy Exploits")
                print("-----------")
                for exploit in my_exploits:
                    print(f"\nExploit #{exploit[0]} by @{exploit[1]}\n")
                    print(f"{exploit[2]}\n")
                    print(f"Hacker ID: {exploit[3]}\n")
                    print("------------------------------\n")

            # Prompting the hacker to enter the exploit number of the exploit they would like to modify
            exploit_selection = int(input("Please enter the exploit number of the exploit you would like to modify: "))
            
            # Prompting the hacker to enter their new exploit
            print(f"\nModifying Exploit #{exploit_selection} by @{hacker_alias}")
            print("------------------------------ \n")
            new_exploit = input("Enter text here: \n\n")

            # If the hacker creates a new exploit without any content, print an error message to hacker and prompt them to enter a valid exploit
            if(new_exploit == ""):
                print("Invalid entry. Please re-enter your entry.")
            else:
                # If the hacker enter a valid exploit, get the old exploit from the database and store it as a variable
                cursor.execute("SELECT content FROM exploits e WHERE e.id = ? AND e.hacker_id = ?", [exploit_selection, hacker_id])
                old_exploit = cursor.fetchall()
                
                # Updating the hacker's old exploit with the new exploit they just entered and committing the changes
                cursor.execute("UPDATE exploits SET content = ? WHERE content = ?", [new_exploit, old_exploit[0][0]])
                conn.commit()

                # If the modified exploit is stored into the database, print a success message to the hacker
                if(cursor.rowcount == 1):
                    print(f"\n@{hacker_alias}'s exploit was successfully updated.")
                    break
                # If the modified exploit is not stored into the database, print an error message to the hacker
                else:
                    print(f"\nFailed to update @{hacker_alias}'s exploit.")
        # If errors occurs during this process, raise the following exceptions, print an error message to the hacker and the traceback
        except mariadb.IntegrityError:
            # An IntegrityError is raised if there is any constraint failure such as a foreign key constraint failure
            print(f"\nErrors found in database due to foreign key contraint failure. Failed to retrieve exploits.\n")
            traceback.print_exc()
        except mariadb.OperationalError:
            # An OperationalError exception is raised for things that are not in control of the programmer such as an unexpected connection failure, server hutting down, etc.
            print(f"\nOperational errors occured when updating Exploit #{exploit_selection}.\n")
            traceback.print_exc()
        except mariadb.ProgrammingError:
            # A ProgrammingError exception is raised if there are errors made by the programmer such as incorrect SQL syntax, getting data from a table that is not found, etc. 
            # In this case, a programming error can occur if the database is unable to recognize between metacharacters and literal strings causing an error to occur
            print(f"\nUnable to escape metacharacters in @{hacker_alias}'s exploit. Failed to upload @{hacker_alias}'s exploit to the database.\n")
            traceback.print_exc()
        except mariadb.NotSupportedError:
            # A NotSupportedError exception is raised if a programmer writes code that is not supported by a certain method such as a MariaDB syntax error
            print("\nInvalid MariaDB syntax.\n")
            traceback.print_exc() 
        except mariadb.DataError:
            # A DataError exception is raised if there are issues with processing data. In this case, the content of the exploit is set to have a maximum of 65,535 characters in length, if a hacker exceeds this limit, an error will occur
            print("\nInvalid data being passed to the database.\n")
            traceback.print_exc()
        except mariadb.DatabaseError:
            # A DatabaseError exception is raised for all errors that are related to the database
            print(f"\nAn error has occured in the database. Failed to retrieve @{hacker_alias}'s exploits.\n")
            traceback.print_exc()
        except IndexError:
            # An IndexError exception is raised if the hacker enters an exploit number that is not owned by them. In the case where a hacker enters an exploit number that doesn't belong to them, an "out of range" error will printed to the terminal.
            print(f"\n@{hacker_alias} is not authorized to modify Exploit #{exploit_selection}.\n")
            traceback.print_exc()
        except ValueError:
            # A ValueError exception is raised if the hacker enters a value that is not an integer data type
            print("\nInvlaid data entry. Expected a numerical type. Please re-enter the exploit number.\n")
            traceback.print_exc()
        except:
            # Catching all other errors
            print(f"\nAn error occured. Failed to upload @{hacker_alias}'s exploit.\n")
            traceback.print_exc()
    
    # Closing the cursor and the database connection
    closing_cursor = dbconnect.close_cursor(cursor)
    closing_db = dbconnect.close_db_connection(conn)

    # If the cursor or database connection failed to close, print an error message
    if(closing_cursor == False or closing_db == False):
        print("\nFailed to close cursor and database connection.")